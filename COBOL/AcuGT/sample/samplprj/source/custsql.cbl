       IDENTIFICATION DIVISION.
       PROGRAM-ID.  CUSTSQL.
      * COPYRIGHT (C) 1996-2006 BY ACUCORP, INC.  USERS OF ACUCOBOL
      * MAY FREELY MODIFY AND REDISTRIBUTE THIS PROGRAM.
       REMARKS.
           THIS PROGRAM READS THRU A CUSTOMER TABLE IN ACCESS, UNTIL THE
           EXIT BUTTON IS PRESSED.  IT WAS DEVELOPED USING SCREENS AND
           COPYFILES GENERATED BY THE ACUBENCH SCREEN PAINTER. 
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
       SPECIAL-NAMES.
      *{Bench}activex-def
      *{Bench}end
      *
       WORKING-STORAGE SECTION.
      *{Bench}acu-def
       COPY "acugui.def".
       COPY "acucobol.def".
       COPY "crtvars.def".
       COPY "showmsg.def".
      *{Bench}end
      *
       77  MB-VALUE                            PIC 9 VALUE 0.
      * 
       78  NEWLINE                             VALUE H"0A".
      *       
      *{Bench}copy-working
       COPY "custsql.wrk".
      *{Bench}end
       COPY RESOURCE "SMPL-ARROWS.BMP".
      * 
           EXEC SQL INCLUDE SQLCA END-EXEC.                             
      *
           EXEC SQL BEGIN DECLARE SECTION END-EXEC.
       01  CUSTOMER-RECORD.
           03  CUSTOMER-ID                     PIC X(10).
           03  CUSTOMER-NAME                   PIC X(30).
           03  CUSTOMER-ADDR-1                 PIC X(40).
           03  CUSTOMER-ADDR-2                 PIC X(40).
           03  CUSTOMER-CITY                   PIC X(15).
           03  CUSTOMER-STATE                  PIC XX.
           03  CUSTOMER-ZIP                    PIC X(10).
           03  CUSTOMER-PHONE                  PIC X(15).
           03  CUSTOMER-CONTACT                PIC X(20).
           EXEC SQL END DECLARE SECTION END-EXEC.
       LINKAGE SECTION.
      *{Bench}linkage
      *{Bench}end
      *
       SCREEN SECTION.
      *{Bench}copy-screen
       COPY "custsql.scr".
      *{Bench}end
       PROCEDURE DIVISION.
       MAIN-LOGIC.
           EXEC SQL WHENEVER SQLERROR GOTO ERROR-EXIT END-EXEC.
      * CREATE CURSOR CALLED CUR1 THAT IS USED THROUGHOUT THE PROGRAM
           EXEC SQL
               DECLARE CUR1 CURSOR  FOR
                   SELECT * FROM CUSTOMER
           END-EXEC.
      *     
           PERFORM INITIALIZATIONS.
      *
           PERFORM UNTIL EXIT-BUTTON-PUSHED
             ACCEPT CUST-SCREEN 
               ON EXCEPTION CONTINUE
             END-ACCEPT
           END-PERFORM.  
      *     
      *    DISCONNECT FROM DATABASE
           EXEC SQL CLOSE CUR1 END-EXEC.
           EXEC SQL COMMIT END-EXEC.
           EXEC SQL DISCONNECT ALL END-EXEC.     
           STOP RUN.
      *    
       INITIALIZATIONS.
      * DISPLAY INITIAL WINDOW     
           PERFORM ACU-INITIAL-ROUTINE.
           PERFORM ACU-CUST-SCREEN-SCRN.

      * LOG ON TO DATABASE     
           DISPLAY MESSAGE BOX 
               "Have you created an ODBC datasource called" NEWLINE
               "50_access pointing to the custsql.mdb Access97" NEWLINE
               "database in the sample project directory?"
               TYPE IS MB-YES-NO
               RETURNING MB-VALUE.
           IF MB-VALUE = MB-YES
               EXEC SQL CONNECT TO "50_access" END-EXEC
           ELSE
      *        PROMPT TO SEE README OR EXIT PROGRAM IMMEDIATELY     
               DISPLAY MESSAGE BOX 
                   "No datasource has been set up. Program is aborting."
                   NEWLINE
                   "Would you like to view the readme file that describe
      -    "s how to set up an ODBC Datasource?"
                   TYPE IS MB-YES-NO
                   RETURNING MB-VALUE
               IF MB-VALUE = MB-YES
                   CALL "C$SYSTEM" USING 
                       "notepad read_me.txt" CSYS-ASYNC
               END-IF
               STOP RUN
           END-IF.

      * OPEN CURSOR, GET FIRST RECORD AND DISPLAY SCREEN
           EXEC SQL OPEN CUR1 END-EXEC.
           EXEC SQL
               FETCH CUR1 INTO :CUSTOMER-RECORD
           END-EXEC.
           PERFORM UPDATE-SCREEN-FIELDS.
           DISPLAY CUST-SCREEN.
      *          
       ERROR-EXIT.
           EXEC SQL WHENEVER SQLERROR CONTINUE END-EXEC.
           DISPLAY MESSAGE BOX 
               "SQL ERROR !" NEWLINE
               "       SQLCODE: " SQLCODE OF SQLCA NEWLINE
               "       SQLSTATE: " SQLSTATE OF SQLCA NEWLINE
               "       SQLERRMC: " SQLERRMC OF SQLCA NEWLINE
               NEWLINE
               "Program Aborting.".
           EXEC SQL DISCONNECT ALL END-EXEC.
           STOP RUN.
      *  
       GET-FIRST-RECORD.
           MOVE 0 TO CUSTOMER-NAME-ENABLED.
           EXEC SQL
             FETCH FIRST FROM CUR1 INTO :CUSTOMER-RECORD
           END-EXEC.
      *
       GET-PREVIOUS-RECORD.
           MOVE 0 TO CUSTOMER-NAME-ENABLED.
           EXEC SQL
             FETCH PRIOR FROM CUR1 INTO :CUSTOMER-RECORD
           END-EXEC.
      *
       GET-NEXT-RECORD.
           MOVE 0 TO CUSTOMER-NAME-ENABLED.
           EXEC SQL
             FETCH NEXT FROM CUR1 INTO :CUSTOMER-RECORD
           END-EXEC.
      *
       GET-LAST-RECORD.
           MOVE 0 TO CUSTOMER-NAME-ENABLED.
           EXEC SQL
             FETCH LAST FROM CUR1 INTO :CUSTOMER-RECORD
           END-EXEC.
      *
       GET-NEW-RECORD.
           MOVE 1 TO CUSTOMER-NAME-ENABLED.
      *
       DELETE-THE-RECORD.
           DISPLAY MESSAGE BOX "ARE YOU SURE?"
             TITLE "DELETING RECORD..."
             TYPE IS MB-YES-NO,
             DEFAULT IS MB-NO,
             ICON IS MB-WARNING-ICON
             GIVING MB-VALUE.
              
           IF MB-VALUE = MB-YES 
      *                DELETE CURRENT RECORD             
             EXEC SQL 
               DELETE FROM CUSTOMER 
               WHERE CURRENT OF CUR1
             END-EXEC
      *                CLOSE AND REOPEN CURSOR SO CURSOR MATCHES 
      *                CURRENT CONTENTS OF DATABASE                 
             EXEC SQL CLOSE CUR1 END-EXEC
             EXEC SQL OPEN CUR1 END-EXEC
             EXEC SQL
               FETCH CUR1 INTO :CUSTOMER-RECORD
             END-EXEC
           END-IF  .
      *
       WRITE-THE-RECORD.
           MOVE 0 TO CUSTOMER-NAME-ENABLED.
           PERFORM UPDATE-RECORD-FIELDS .
           EXEC SQL 
             INSERT INTO CUSTOMER VALUES
              (:CUSTOMER-ID,:CUSTOMER-NAME,:CUSTOMER-ADDR-1,
               :CUSTOMER-ADDR-2,:CUSTOMER-CITY,:CUSTOMER-STATE,
               :CUSTOMER-ZIP,:CUSTOMER-PHONE,:CUSTOMER-CONTACT)
           END-EXEC.
      *
      *{Bench}copy-procedure
       COPY "showmsg.cpy".
       COPY "custsql.prd".
       COPY "custsql.mnu".
       COPY "custsql.evt".
      *{Bench}end
           
       
